# perf script event handlers, generated by perf script -g python
# Licensed under the terms of the GNU GPL License version 2

# The common_* event handler fields are the most useful fields common to
# all events.  They don't necessarily correspond to the 'common_*' fields
# in the format files.  Those fields not available as handler params can
# be retrieved using Python functions of the form common_*(context).
# See the perf-script-python Documentation for the list of available functions.

from __future__ import print_function

import os
import sys
import json

sys.path.append(os.environ['PERF_EXEC_PATH'] + \
        '/scripts/python/Perf-Trace-Util/lib/Perf/Trace')

# from perf_trace_context import perf_sample_srcline, perf_script_context
import perf_trace_context as perf
from Core import *

# allows aggregating and renaming
remaps = {
    '/usr/lib/zig/std': 'zig-std',
}

def populateRemapsFromZigPkgCache():
    import re
    zon_name_pat = re.compile(
        r'\.name\s*=\s*"(?P<name>[^"]*)"',
        flags=re.M
    )
    zon_vers_pat = re.compile(
        r'\.version\s*=\s*"(?P<ver>[^"]*)"',
        flags=re.M
    )
    readme_name_pat = re.compile(r'^# \s*(.+)\s*($|<!--)', flags=re.M)

    zig_pkgs_root = os.path.join(os.environ['HOME'] + '/.cache/zig/p')
    for pkg_hash in os.listdir(zig_pkgs_root):
        # NOTE: I assume C dependencies might not have a build.zig.zon
        pkg_path = os.path.join(zig_pkgs_root, pkg_hash)
        name = None
        version = pkg_hash[:16] # FIXME: make accurate

        zon_path = os.path.join(pkg_path, 'build.zig.zon')
        readme_path = os.path.join(pkg_path, 'README.md')
        if os.access(zon_path, os.F_OK):
            try:
                with open(zon_path, 'r') as zon:
                    content = zon.read()
                    name = zon_name_pat.search(content)['name']
                    version = zon_vers_pat.search(content)['ver'] + f'+{pkg_hash[:16]}'
            except Exception as e:
                sys.stderr.write(f'Error reading zon "{zon_path}": {e}\n')
        elif os.access(readme_path, os.F_OK):
            try:
                # TODO: try non-md
                with open(readme_path, 'r') as readme:
                    parsed = readme_name_pat.search(readme.read())
                    name = parsed[1]
            except Exception as e:
                sys.stderr.write(f'Error reading readme "{readme_path}": {e}\n')


        if name is not None:
            remaps[pkg_path] = f"{name}@{version}"

populateRemapsFromZigPkgCache()

dirs = {}

def trace_begin():
    pass

def trace_end():
    print(f"Summary:")
    for dir, count in sorted(dirs.items(), key=lambda t: -t[1]):
        print(f"{dir}: {count}")

def process_event(event):
    file, _line = perf.perf_sample_srcline(perf.perf_script_context)
    if file is not None:
        # TODO: this could be more efficient via prefix searches
        key = os.path.dirname(file)
        for prefix, target in remaps.items():
            if file.startswith(prefix):
                key = target
                break
        dirs[key] = dirs.get(key, 0) + 1

def trace_unhandled(event_name, context, event_fields_dict, perf_sample_dict):
    print("unhandled tracepoint")
